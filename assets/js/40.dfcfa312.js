(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{322:function(e,v,_){"use strict";_.r(v);var t=_(14),a=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"_1-vue基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue基础"}},[e._v("#")]),e._v(" 1. Vue基础")]),e._v(" "),v("h2",{attrs:{id:"_1-computed-和-watch-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-computed-和-watch-的区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("1. Computed 和 Watch 的区别")])]),e._v(" "),v("ul",[v("li",[e._v("computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。")]),e._v(" "),v("li",[e._v("watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。")]),e._v(" "),v("li",[e._v("运用场景\n"),v("ul",[v("li",[e._v("当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。")]),e._v(" "),v("li",[e._v("当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])])])]),e._v(" "),v("h2",{attrs:{id:"_2-常见的事件修饰符及其作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-常见的事件修饰符及其作用"}},[e._v("#")]),e._v(" "),v("strong",[e._v("2. 常见的事件修饰符及其作用")])]),e._v(" "),v("ul",[v("li",[e._v(".stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；")]),e._v(" "),v("li",[e._v(".prevent：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；")]),e._v(" "),v("li",[e._v(".capture：与事件冒泡的方向相反，事件捕获由外到内；")]),e._v(" "),v("li",[e._v(".self：只会触发自己范围内的事件，不包含子元素；")]),e._v(" "),v("li",[e._v(".once：只会触发一次")])]),e._v(" "),v("h2",{attrs:{id:"_3-v-if和v-show的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-v-if和v-show的区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("3. v-if和v-show的区别")])]),e._v(" "),v("ul",[v("li",[e._v("手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；")]),e._v(" "),v("li",[e._v("编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；")]),e._v(" "),v("li",[e._v("编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；")]),e._v(" "),v("li",[e._v("性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；")]),e._v(" "),v("li",[e._v("使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。")])]),e._v(" "),v("h2",{attrs:{id:"_4-data-为什么是一个函数而不是对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-data-为什么是一个函数而不是对象"}},[e._v("#")]),e._v(" "),v("strong",[e._v("4. data 为什么是一个函数而不是对象")])]),e._v(" "),v("ul",[v("li",[e._v("JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。")]),e._v(" "),v("li",[e._v("而在 Vue 中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。")]),e._v(" "),v("li",[e._v("所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。")])]),e._v(" "),v("h2",{attrs:{id:"_5-vue中封装的数组方法有哪些-其如何实现页面更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue中封装的数组方法有哪些-其如何实现页面更新"}},[e._v("#")]),e._v(" "),v("strong",[e._v("5. Vue中封装的数组方法有哪些，其如何实现页面更新")])]),e._v(" "),v("ul",[v("li",[e._v('"push","pop",  "shift",  "unshift",  "splice",  "sort",  "reverse"')]),e._v(" "),v("li",[e._v("在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。")])]),e._v(" "),v("h2",{attrs:{id:"_6-谈谈mvvm"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-谈谈mvvm"}},[e._v("#")]),e._v(" "),v("strong",[e._v("6. 谈谈MVVM")])]),e._v(" "),v("ul",[v("li",[e._v("MVVM 分为 Model、View、ViewModel：")]),e._v(" "),v("li",[e._v("Model代表数据模型，数据和业务逻辑都在Model层中定义；")]),e._v(" "),v("li",[e._v("View代表UI视图，负责数据的展示；")]),e._v(" "),v("li",[e._v("ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；")]),e._v(" "),v("li",[e._v("Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。")]),e._v(" "),v("li",[e._v("这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。")])]),e._v(" "),v("h2",{attrs:{id:"_7-使用-object-defineproperty-来进行数据劫持有什么缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-使用-object-defineproperty-来进行数据劫持有什么缺点"}},[e._v("#")]),e._v(" "),v("strong",[e._v("7. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？")])]),e._v(" "),v("ul",[v("li",[e._v("在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。")]),e._v(" "),v("li",[e._v("在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。")])]),e._v(" "),v("h2",{attrs:{id:"_8-说一下vue的生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-说一下vue的生命周期"}},[e._v("#")]),e._v(" "),v("strong",[e._v("8. 说一下Vue的生命周期")])]),e._v(" "),v("ul",[v("li",[e._v("概念：Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。")]),e._v(" "),v("li",[e._v("beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。")]),e._v(" "),v("li",[e._v("created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 "),v("code",[e._v("$el")]),e._v(" 属性。")]),e._v(" "),v("li",[e._v("beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。")]),e._v(" "),v("li",[e._v("mounted（挂载后）：在el被新创建的 "),v("code",[e._v("vm.$el")]),e._v(" 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。")]),e._v(" "),v("li",[e._v("beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。")]),e._v(" "),v("li",[e._v("updated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。")]),e._v(" "),v("li",[e._v("beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。")]),e._v(" "),v("li",[e._v("destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。")]),e._v(" "),v("li",[e._v("另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。")])]),e._v(" "),v("h2",{attrs:{id:"_9-vue-子组件和父组件执行顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-子组件和父组件执行顺序"}},[e._v("#")]),e._v(" "),v("strong",[e._v("9. Vue 子组件和父组件执行顺序")])]),e._v(" "),v("ul",[v("li",[e._v("加载渲染过程：\n"),v("ul",[v("li",[e._v("父组件 beforeCreate")]),e._v(" "),v("li",[e._v("父组件 created")]),e._v(" "),v("li",[e._v("父组件 beforeMount")]),e._v(" "),v("li",[e._v("子组件 beforeCreate")]),e._v(" "),v("li",[e._v("子组件 created")]),e._v(" "),v("li",[e._v("子组件 beforeMount")]),e._v(" "),v("li",[e._v("子组件 mounted")]),e._v(" "),v("li",[e._v("父组件 mounted")])])]),e._v(" "),v("li",[e._v("更新过程：\n"),v("ul",[v("li",[e._v("父组件 beforeUpdate")]),e._v(" "),v("li",[e._v("子组件 beforeUpdate")]),e._v(" "),v("li",[e._v("子组件 updated")]),e._v(" "),v("li",[e._v("父组件 updated")])])]),e._v(" "),v("li",[e._v("销毁过程：\n"),v("ul",[v("li",[e._v("父组件 beforeDestroy")]),e._v(" "),v("li",[e._v("子组件 beforeDestroy")]),e._v(" "),v("li",[e._v("子组件 destroyed")]),e._v(" "),v("li",[e._v("父组件 destoryed")])])])]),e._v(" "),v("h2",{attrs:{id:"_10-一般在哪个生命周期请求异步数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-一般在哪个生命周期请求异步数据"}},[e._v("#")]),e._v(" "),v("strong",[e._v("10. 一般在哪个生命周期请求异步数据")])]),e._v(" "),v("ul",[v("li",[e._v("我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。")]),e._v(" "),v("li",[e._v("推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n"),v("ul",[v("li",[e._v("能更快获取到服务端数据，减少页面加载时间，用户体验更好；")]),e._v(" "),v("li",[e._v("SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。")])])])]),e._v(" "),v("h2",{attrs:{id:"_11-vue-组件通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-组件通信方式"}},[e._v("#")]),e._v(" "),v("strong",[e._v("11. Vue 组件通信方式")])]),e._v(" "),v("p",[e._v("（1）父子组件间通信")]),e._v(" "),v("ul",[v("li",[e._v("子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 "),v("code",[e._v("$emit")]),e._v(" 触发事件来向父组件发送数据。")]),e._v(" "),v("li",[e._v("通过 ref 属性给子组件设置一个名字。父组件通过 "),v("code",[e._v("$refs")]),e._v(" 组件名来获得子组件，子组件通过 "),v("code",[e._v("$parent")]),e._v(" 获得父组件，这样也可以实现通信。")]),e._v(" "),v("li",[e._v("使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。")])]),e._v(" "),v("p",[e._v("（2）兄弟组件间通信")]),e._v(" "),v("ul",[v("li",[e._v("使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。")]),e._v(" "),v("li",[e._v("通过 "),v("code",[e._v("$parent/$refs")]),e._v(" 来获取到兄弟组件，也可以进行通信。")])]),e._v(" "),v("p",[e._v("（3）任意组件之间")]),e._v(" "),v("ul",[v("li",[e._v("使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。")]),e._v(" "),v("li",[e._v("Vuex：如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用vuex，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。")])]),e._v(" "),v("h2",{attrs:{id:"_12-vue-路由模式有哪些-有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue-路由模式有哪些-有什么区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("12. Vue 路由模式有哪些？有什么区别？")])]),e._v(" "),v("ul",[v("li",[e._v("vue的路由模式⼀共有两种,分别是hash和history")]),e._v(" "),v("li",[e._v("区别\n"),v("ul",[v("li",[e._v("它们的区别是 hash 模式不会包含在 http 请求当中,并且 hash 不会重新加载⻚⾯")]),e._v(" "),v("li",[e._v("使⽤history模式的话,如果前端的url和后端发起请求的url不⼀致的话,会 报404错误,所以使⽤history模块的话我们需要和后端进⾏配合.")])])]),e._v(" "),v("li",[e._v("原理\n"),v("ul",[v("li",[e._v("history的原理就是利⽤html5新增的两个特性⽅法,分别是psuhState和replaceState来完成的，这就是我对vue路由模式的理解")])])])]),e._v(" "),v("h2",{attrs:{id:"_13-说说-vue-router-的-hash模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-说说-vue-router-的-hash模式"}},[e._v("#")]),e._v(" "),v("strong",[e._v("13. 说说 Vue Router 的 hash模式")])]),e._v(" "),v("ul",[v("li",[e._v("简介： hash模式是开发中默认的模式，它的URL带着一个#，例如："),v("code",[e._v("www.abc.com/#/vue")]),e._v("，它的hash值就是"),v("code",[e._v("#/vue")]),e._v("。")]),e._v(" "),v("li",[e._v("特点：hash值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。")]),e._v(" "),v("li",[e._v("原理： hash 模式的主要原理就是 onhashchange() 事件。")]),e._v(" "),v("li",[e._v("使用 onhashchange() 事件的好处就是，在页面的 hash 值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。")])]),e._v(" "),v("h2",{attrs:{id:"_14-route-和-router-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-route-和-router-的区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("14. "),v("code",[e._v("$route")]),e._v(" 和"),v("code",[e._v("$router")]),e._v(" 的区别")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("$route")]),e._v(" 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数")]),e._v(" "),v("li",[v("code",[e._v("$router")]),e._v(" 是“路由实例”对象包括了路由的跳转方法，钩子函数等。")])]),e._v(" "),v("h2",{attrs:{id:"_15-vuex-是什么-核心流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-vuex-是什么-核心流程"}},[e._v("#")]),e._v(" "),v("strong",[e._v("15. Vuex 是什么？核心流程？")])]),e._v(" "),v("ul",[v("li",[v("p",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。")]),e._v(" "),v("ul",[v("li",[e._v("Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。")]),e._v(" "),v("li",[e._v("改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。")])])]),e._v(" "),v("li",[v("p",[e._v("核心流程中的主要功能：\n"),v("img",{attrs:{src:e.$withBase("/img/frame_vuex.jpg")}})])]),e._v(" "),v("li",[v("p",[e._v("Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;")])]),e._v(" "),v("li",[v("p",[e._v("在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;")])]),e._v(" "),v("li",[v("p",[e._v("然后 Mutations 就去改变（Mutate）State 中的数据;")])]),e._v(" "),v("li",[v("p",[e._v("当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。")])])]),e._v(" "),v("h2",{attrs:{id:"_16-vuex中action和mutation的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-vuex中action和mutation的区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("16. Vuex中action和mutation的区别")])]),e._v(" "),v("ul",[v("li",[e._v("Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。")]),e._v(" "),v("li",[e._v("Mutation：必须同步执行；Action：可以异步，但不能直接操作State。")]),e._v(" "),v("li",[e._v("在视图更新时，先触发actions，actions再触发mutation")]),e._v(" "),v("li",[e._v("mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters")])]),e._v(" "),v("h2",{attrs:{id:"_17-redux-和-vuex-有什么区别-它们的共同思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-redux-和-vuex-有什么区别-它们的共同思想"}},[e._v("#")]),e._v(" "),v("strong",[e._v("17. Redux 和 Vuex 有什么区别，它们的共同思想")])]),e._v(" "),v("p",[e._v("（1）Redux 和 Vuex区别")]),e._v(" "),v("ul",[v("li",[e._v("Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可")]),e._v(" "),v("li",[e._v("Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可")]),e._v(" "),v("li",[e._v("Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）")])]),e._v(" "),v("p",[e._v("（2）共同思想")]),e._v(" "),v("ul",[v("li",[e._v("单—的数据源")]),e._v(" "),v("li",[e._v("变化可以预测")]),e._v(" "),v("li",[e._v("本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;")])]),e._v(" "),v("h2",{attrs:{id:"_18-vuex-和-localstorage-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-vuex-和-localstorage-的区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("18. Vuex 和 localStorage 的区别")])]),e._v(" "),v("p",[e._v("（1）最重要的区别")]),e._v(" "),v("ul",[v("li",[e._v("vuex存储在内存中")]),e._v(" "),v("li",[e._v("localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快")])]),e._v(" "),v("p",[e._v("（2）应用场景")]),e._v(" "),v("ul",[v("li",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。")]),e._v(" "),v("li",[e._v("localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。")]),e._v(" "),v("li",[e._v("Vuex能做到数据的响应式，localstorage不能")])]),e._v(" "),v("p",[e._v("（3）永久性")]),e._v(" "),v("ul",[v("li",[e._v("刷新页面时vuex存储的值会丢失，localstorage不会。")]),e._v(" "),v("li",[e._v("注意： 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。")])]),e._v(" "),v("h2",{attrs:{id:"_19-vue3-0有什么更新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue3-0有什么更新"}},[e._v("#")]),e._v(" "),v("strong",[e._v("19. Vue3.0有什么更新")])]),e._v(" "),v("p",[e._v("（1）监测机制的改变")]),e._v(" "),v("ul",[v("li",[e._v("3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。")]),e._v(" "),v("li",[e._v("消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：")])]),e._v(" "),v("p",[e._v("（2）只能监测属性，不能监测对象")]),e._v(" "),v("ul",[v("li",[e._v("检测属性的添加和删除；")]),e._v(" "),v("li",[e._v("检测数组索引和长度的变更；")]),e._v(" "),v("li",[e._v("支持 Map、Set、WeakMap 和 WeakSet。")])]),e._v(" "),v("p",[e._v("（3）模板")]),e._v(" "),v("ul",[v("li",[e._v("作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。")]),e._v(" "),v("li",[e._v("同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。")])]),e._v(" "),v("p",[e._v("（4）对象式的组件声明方式")]),e._v(" "),v("ul",[v("li",[e._v("vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。")]),e._v(" "),v("li",[e._v("3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易")])]),e._v(" "),v("p",[e._v("（5）其它方面的更改")]),e._v(" "),v("ul",[v("li",[e._v("支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。")]),e._v(" "),v("li",[e._v("支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。")]),e._v(" "),v("li",[e._v("基于 tree shaking 优化，提供了更多的内置功能。")])]),e._v(" "),v("h2",{attrs:{id:"_20-defineproperty和proxy的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-defineproperty和proxy的区别"}},[e._v("#")]),e._v(" "),v("strong",[e._v("20. defineProperty和proxy的区别")])]),e._v(" "),v("ul",[v("li",[e._v("Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。")]),e._v(" "),v("li",[e._v("Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。")]),e._v(" "),v("li",[e._v("但是这样做有以下问题：\n"),v("ul",[v("li",[e._v("添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过"),v("code",[e._v("$set")]),e._v(" 来调用Object.defineProperty()处理。")]),e._v(" "),v("li",[e._v("无法监控到数组下标和长度的变化。")])])]),e._v(" "),v("li",[e._v("Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：\n"),v("ul",[v("li",[e._v("Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。")]),e._v(" "),v("li",[e._v("Proxy 可以监听数组的变化。")])])])]),e._v(" "),v("h2",{attrs:{id:"_21-对虚拟dom的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-对虚拟dom的理解"}},[e._v("#")]),e._v(" "),v("strong",[e._v("21. 对虚拟DOM的理解？")])]),e._v(" "),v("ul",[v("li",[e._v("从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。")]),e._v(" "),v("li",[e._v("虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。")]),e._v(" "),v("li",[e._v("另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。")])]),e._v(" "),v("h2",{attrs:{id:"_22-虚拟dom的解析过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-虚拟dom的解析过程"}},[e._v("#")]),e._v(" "),v("strong",[e._v("22. 虚拟DOM的解析过程")])]),e._v(" "),v("ul",[v("li",[e._v("首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。")]),e._v(" "),v("li",[e._v("当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。")]),e._v(" "),v("li",[e._v("最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。")])]),e._v(" "),v("h2",{attrs:{id:"_23-双向数据绑定的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-双向数据绑定的原理"}},[e._v("#")]),e._v(" "),v("strong",[e._v("23. 双向数据绑定的原理")])]),e._v(" "),v("ul",[v("li",[e._v("Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：")]),e._v(" "),v("li",[e._v("需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化")]),e._v(" "),v("li",[e._v("compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),v("li",[e._v("Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:\n"),v("ul",[v("li",[e._v("①在自身实例化时往属性订阅器(dep)里面添加自己")]),e._v(" "),v("li",[e._v("②自身必须有一个update()方法")]),e._v(" "),v("li",[e._v("③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")])])]),e._v(" "),v("li",[e._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n"),v("img",{attrs:{src:e.$withBase("/img/frame_mvvm.jpeg")}})])]),e._v(" "),v("h2",{attrs:{id:"_24-diff-算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24-diff-算法"}},[e._v("#")]),e._v(" "),v("strong",[e._v("24. Diff 算法")])]),e._v(" "),v("ul",[v("li",[e._v("在新老虚拟DOM对比时：")]),e._v(" "),v("li",[e._v("首先，对比节点本身\n"),v("ul",[v("li",[e._v("没有新节点，直接触发旧节点的destory钩子")]),e._v(" "),v("li",[e._v("没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm")]),e._v(" "),v("li",[e._v("旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点")]),e._v(" "),v("li",[e._v("旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点")])])]),e._v(" "),v("li",[e._v("如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\n"),v("ul",[v("li",[e._v("新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容")]),e._v(" "),v("li",[e._v("新节点和旧节点如果都有子节点，则处理比较更新子节点")]),e._v(" "),v("li",[e._v("只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点")]),e._v(" "),v("li",[e._v("只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除")])])]),e._v(" "),v("li",[e._v("比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。\n"),v("ul",[v("li",[e._v("设置新旧VNode的头尾指针")]),e._v(" "),v("li",[e._v("新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作")])])]),e._v(" "),v("li",[e._v("匹配时，找到相同的子节点，递归比较子节点")]),e._v(" "),v("li",[e._v("在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。")])]),e._v(" "),v("h2",{attrs:{id:"_25-vue-为什么要设置-key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-vue-为什么要设置-key"}},[e._v("#")]),e._v(" "),v("strong",[e._v("25. Vue 为什么要设置 key？")])]),e._v(" "),v("ul",[v("li",[v("p",[e._v("vue 中 key 值的作用可以分为两种情况来考虑：")]),e._v(" "),v("ul",[v("li",[e._v("第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。")]),e._v(" "),v("li",[e._v("第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。")])])]),e._v(" "),v("li",[v("p",[e._v("key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速")]),e._v(" "),v("ul",[v("li",[e._v("更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。")]),e._v(" "),v("li",[e._v("更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快")])])])]),e._v(" "),v("h2",{attrs:{id:"_26-为什么不建议用index作为key"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_26-为什么不建议用index作为key"}},[e._v("#")]),e._v(" "),v("strong",[e._v("26. 为什么不建议用index作为key?")])]),e._v(" "),v("ul",[v("li",[e._v("使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。")])]),e._v(" "),v("h2",{attrs:{id:"_27-编译的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_27-编译的过程"}},[e._v("#")]),e._v(" "),v("strong",[e._v("27. 编译的过程")])]),e._v(" "),v("ul",[v("li",[e._v("将模板解析为 AST\n"),v("ul",[v("li",[e._v("最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象")])])]),e._v(" "),v("li",[e._v("优化 AST\n"),v("ul",[v("li",[e._v("对静态节点做优化")])])]),e._v(" "),v("li",[e._v("将 AST 转换为 render 函数")])]),e._v(" "),v("h2",{attrs:{id:"_28-nexttick-原理分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_28-nexttick-原理分析"}},[e._v("#")]),e._v(" "),v("strong",[e._v("28. NextTick 原理分析")])]),e._v(" "),v("ul",[v("li",[e._v("对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout")]),e._v(" "),v("li",[e._v("Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。")]),e._v(" "),v("li",[e._v("nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。")]),e._v(" "),v("li",[e._v("nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理")]),e._v(" "),v("li",[e._v("问题\n"),v("ul",[v("li",[e._v("如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染")]),e._v(" "),v("li",[e._v("同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);
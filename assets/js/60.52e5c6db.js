(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{339:function(v,_,t){"use strict";t.r(_);var l=t(14),i=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"_5-重排与重绘的区别-什么情况下会触发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-重排与重绘的区别-什么情况下会触发"}},[v._v("#")]),v._v(" 5. 重排与重绘的区别，什么情况下会触发？")]),v._v(" "),_("p",[v._v("参考答案：")]),v._v(" "),_("p",[v._v("1.简述重排的概念")]),v._v(" "),_("p",[v._v("浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM 树和渲染树），DOM 树表示页面结构，渲染树表示 DOM 节点如何显示。重排是 DOM 元素的几何属性变化，DOM 树的结构变化，渲染树需要重新计算。")]),v._v(" "),_("p",[v._v("2.简述重绘的概念")]),v._v(" "),_("p",[v._v("重绘是一个元素外观的改变所触发的浏览器行为，例如改变 visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但 table 及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。")]),v._v(" "),_("p",[v._v("3.简述重绘和重排的关系")]),v._v(" "),_("p",[v._v("重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。")]),v._v(" "),_("p",[v._v("4.什么情况下会触发重排？")]),v._v(" "),_("ul",[_("li",[v._v("页面渲染初始化时；（这个无法避免）")]),v._v(" "),_("li",[v._v("浏览器窗口改变尺寸；")]),v._v(" "),_("li",[v._v("元素尺寸改变时；")]),v._v(" "),_("li",[v._v("元素位置改变时；")]),v._v(" "),_("li",[v._v("元素内容改变时；")]),v._v(" "),_("li",[v._v("添加或删除可见的 DOM 元素时。")])]),v._v(" "),_("p",[v._v("5.重排优化有如下五种方法")]),v._v(" "),_("ul",[_("li",[v._v("将多次改变样式属性的操作合并成一次操作，减少 DOM 访问。")]),v._v(" "),_("li",[v._v("如果要批量添加 DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment 元素的应用）")]),v._v(" "),_("li",[v._v("将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。")]),v._v(" "),_("li",[v._v("由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。")]),v._v(" "),_("li",[v._v("在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的 html 片段，再一次性添加到文档中去，而不是循环添加每一行。")])])])}),[],!1,null,null,null);_.default=i.exports}}]);